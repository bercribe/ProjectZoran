<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Neural networks playing platformers | Your awesome title</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Neural networks playing platformers" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I decided a good place to start would be the MarI/O source code. MarI/O is designed to work with the BizHawk emulator. This emulator is designed with TASBots in mind, it allows the saving and loading of save states and execution of LUA scripts. MarI/O is essentially a huge LUA script. It works on the assumption that it is always beneficial for Mario to move towards the right side of the screen, and uses a Fitness metric calculated with this assumption in mind. It uses this metric to judge the success of neural networks generated via the NEAT method. The system iteratively tests these networks by having them play Mario. It then combines successful networks and eliminates unsuccessful ones. This is a gross oversimplification of the process, the system requires hundreds, if not thousands of repetitions to yield much success. To test my understanding of the system, I attempted a modification of MarI/O that would allow it to play Castlevania instead. MarI/O fetches Mario&#39;s location, tile information, and enemy information by reading the RAM of the executing ROM. I had to modify this to fetch Simon&#39;s location and the location of enemies. I was unable to make a direct translation from Mario&#39;s tile reading method to Castlevania&#39;s, so I left this element out of the equation. I then allowed the system to run over and over again. By generation 8, the bot was able to make it to the second room sometimes. At this point, I realized that the Fitness metric used by Mario was too simple for Castlevania since the rightmost side of the screen is not the end of the second room, the player must instead descend the stairs into the basement. I also discovered that Simon&#39;s position wasn&#39;t being tracked globally, it was only being tracked per room. Thus, the Fitness metric stopped counting after the first room. If repeated with these fixes, this experiment could probably get better results. The earliest effective strategy for the bot was a stutter step, involving using the whip every second or so and walking to the right. The bot made it to the end of the first room before being reset. In later generations, the most effective strategy was to jump over ghosts and damage boost past them. More detailed data about the Castlevania training can be found here. I also began preparing to apply the NEAT system to a more recent game - Celeste. Celeste has a large speed running and modding scene, it also features complex mechanics and entirely deterministic gameplay. These features make it an excellent candidate for NEAT. I installed Everest, a Celeste mod loader and modding API. By opening the game and enabling debug mode, I discovered that the necessary components for NEAT were made readily available by Everest: the player&#39;s position, the level tiles, and special entities like spikes and springs. The stages were even labeled in numerically increasing order from the start to the end of the level. This should make it possible to either develop a mod that performs NEAT in a self contained format, or develop a mod that supplies entity information for use in a 3rd party program running NEAT. I&#39;ll have to experiment a lot with Fitness metrics. One option is to track the distance the player is from the end of the level at any given time. Another possibility involves tracking the distance the player is from the next stage toward the end of the level. This would require more work initially, but might yield faster results. I&#39;m excited to start applying NEAT to Celeste in the near future." />
<meta property="og:description" content="I decided a good place to start would be the MarI/O source code. MarI/O is designed to work with the BizHawk emulator. This emulator is designed with TASBots in mind, it allows the saving and loading of save states and execution of LUA scripts. MarI/O is essentially a huge LUA script. It works on the assumption that it is always beneficial for Mario to move towards the right side of the screen, and uses a Fitness metric calculated with this assumption in mind. It uses this metric to judge the success of neural networks generated via the NEAT method. The system iteratively tests these networks by having them play Mario. It then combines successful networks and eliminates unsuccessful ones. This is a gross oversimplification of the process, the system requires hundreds, if not thousands of repetitions to yield much success. To test my understanding of the system, I attempted a modification of MarI/O that would allow it to play Castlevania instead. MarI/O fetches Mario&#39;s location, tile information, and enemy information by reading the RAM of the executing ROM. I had to modify this to fetch Simon&#39;s location and the location of enemies. I was unable to make a direct translation from Mario&#39;s tile reading method to Castlevania&#39;s, so I left this element out of the equation. I then allowed the system to run over and over again. By generation 8, the bot was able to make it to the second room sometimes. At this point, I realized that the Fitness metric used by Mario was too simple for Castlevania since the rightmost side of the screen is not the end of the second room, the player must instead descend the stairs into the basement. I also discovered that Simon&#39;s position wasn&#39;t being tracked globally, it was only being tracked per room. Thus, the Fitness metric stopped counting after the first room. If repeated with these fixes, this experiment could probably get better results. The earliest effective strategy for the bot was a stutter step, involving using the whip every second or so and walking to the right. The bot made it to the end of the first room before being reset. In later generations, the most effective strategy was to jump over ghosts and damage boost past them. More detailed data about the Castlevania training can be found here. I also began preparing to apply the NEAT system to a more recent game - Celeste. Celeste has a large speed running and modding scene, it also features complex mechanics and entirely deterministic gameplay. These features make it an excellent candidate for NEAT. I installed Everest, a Celeste mod loader and modding API. By opening the game and enabling debug mode, I discovered that the necessary components for NEAT were made readily available by Everest: the player&#39;s position, the level tiles, and special entities like spikes and springs. The stages were even labeled in numerically increasing order from the start to the end of the level. This should make it possible to either develop a mod that performs NEAT in a self contained format, or develop a mod that supplies entity information for use in a 3rd party program running NEAT. I&#39;ll have to experiment a lot with Fitness metrics. One option is to track the distance the player is from the end of the level at any given time. Another possibility involves tracking the distance the player is from the next stage toward the end of the level. This would require more work initially, but might yield faster results. I&#39;m excited to start applying NEAT to Celeste in the near future." />
<link rel="canonical" href="/2019/02/10/neural-networks-playing-platformers/" />
<meta property="og:url" content="/2019/02/10/neural-networks-playing-platformers/" />
<meta property="og:site_name" content="Your awesome title" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-02-10T19:48:27-08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Neural networks playing platformers" />
<script type="application/ld+json">
{"@type":"BlogPosting","url":"/2019/02/10/neural-networks-playing-platformers/","dateModified":"2019-02-10T19:48:27-08:00","datePublished":"2019-02-10T19:48:27-08:00","headline":"Neural networks playing platformers","mainEntityOfPage":{"@type":"WebPage","@id":"/2019/02/10/neural-networks-playing-platformers/"},"description":"I decided a good place to start would be the MarI/O source code. MarI/O is designed to work with the BizHawk emulator. This emulator is designed with TASBots in mind, it allows the saving and loading of save states and execution of LUA scripts. MarI/O is essentially a huge LUA script. It works on the assumption that it is always beneficial for Mario to move towards the right side of the screen, and uses a Fitness metric calculated with this assumption in mind. It uses this metric to judge the success of neural networks generated via the NEAT method. The system iteratively tests these networks by having them play Mario. It then combines successful networks and eliminates unsuccessful ones. This is a gross oversimplification of the process, the system requires hundreds, if not thousands of repetitions to yield much success. To test my understanding of the system, I attempted a modification of MarI/O that would allow it to play Castlevania instead. MarI/O fetches Mario&#39;s location, tile information, and enemy information by reading the RAM of the executing ROM. I had to modify this to fetch Simon&#39;s location and the location of enemies. I was unable to make a direct translation from Mario&#39;s tile reading method to Castlevania&#39;s, so I left this element out of the equation. I then allowed the system to run over and over again. By generation 8, the bot was able to make it to the second room sometimes. At this point, I realized that the Fitness metric used by Mario was too simple for Castlevania since the rightmost side of the screen is not the end of the second room, the player must instead descend the stairs into the basement. I also discovered that Simon&#39;s position wasn&#39;t being tracked globally, it was only being tracked per room. Thus, the Fitness metric stopped counting after the first room. If repeated with these fixes, this experiment could probably get better results. The earliest effective strategy for the bot was a stutter step, involving using the whip every second or so and walking to the right. The bot made it to the end of the first room before being reset. In later generations, the most effective strategy was to jump over ghosts and damage boost past them. More detailed data about the Castlevania training can be found here. I also began preparing to apply the NEAT system to a more recent game - Celeste. Celeste has a large speed running and modding scene, it also features complex mechanics and entirely deterministic gameplay. These features make it an excellent candidate for NEAT. I installed Everest, a Celeste mod loader and modding API. By opening the game and enabling debug mode, I discovered that the necessary components for NEAT were made readily available by Everest: the player&#39;s position, the level tiles, and special entities like spikes and springs. The stages were even labeled in numerically increasing order from the start to the end of the level. This should make it possible to either develop a mod that performs NEAT in a self contained format, or develop a mod that supplies entity information for use in a 3rd party program running NEAT. I&#39;ll have to experiment a lot with Fitness metrics. One option is to track the distance the player is from the end of the level at any given time. Another possibility involves tracking the distance the player is from the next stage toward the end of the level. This would require more work initially, but might yield faster results. I&#39;m excited to start applying NEAT to Celeste in the near future.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Your awesome title" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Your awesome title</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Neural networks playing platformers</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-02-10T19:48:27-08:00" itemprop="datePublished">Feb 10, 2019
      </time>â€¢ <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">{"login"=>"bercribe", "email"=>"matoska.polar.waltz@gmail.com", "display_name"=>"mawz", "first_name"=>"", "last_name"=>""}</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><!-- wp:paragraph --></p>
<p>I decided a good place to start would be the <a href="https://www.youtube.com/watch?v=qv6UVOQ0F44">MarI/O</a> source code. MarI/O is designed to work with the <a href="http://tasvideos.org/BizHawk.html">BizHawk emulator</a>. This emulator is designed with TASBots in mind, it allows the saving and loading of save states and execution of LUA scripts. MarI/O is essentially a huge LUA script. It works on the assumption that it is always beneficial for Mario to move towards the right side of the screen, and uses a Fitness metric calculated with this assumption in mind. It uses this metric to judge the success of neural networks generated via the <a href="http://nn.cs.utexas.edu/downloads/papers/stanley.ec02.pdf">NEAT</a> method. The system iteratively tests these networks by having them play Mario. It then combines successful networks and eliminates unsuccessful ones. This is a gross oversimplification of the process, the system requires hundreds, if not thousands of repetitions to yield much success.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>To test my understanding of the system, I attempted a modification of MarI/O that would allow it to play Castlevania instead. MarI/O fetches Mario's location, tile information, and enemy information by reading the RAM of the executing ROM. I had to modify this to fetch Simon's location and the location of enemies. I was unable to make a direct translation from Mario's tile reading method to Castlevania's, so I left this element out of the equation. I then allowed the system to run over and over again. By generation 8, the bot was able to make it to the second room sometimes. At this point, I realized that the Fitness metric used by Mario was too simple for Castlevania since the rightmost side of the screen is not the end of the second room, the player must instead descend the stairs into the basement. I also discovered that Simon's position wasn't being tracked globally, it was only being tracked per room. Thus, the Fitness metric stopped counting after the first room. If repeated with these fixes, this experiment could probably get better results. The earliest effective strategy for the bot was a stutter step, involving using the whip every second or so and walking to the right. The bot made it to the end of the first room before being reset. In later generations, the most effective strategy was to jump over ghosts and damage boost past them. More detailed data about the Castlevania training can be found <a href="https://pastebin.com/16pqaUMK">here</a>.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>I also began preparing to apply the NEAT system to a more recent game - <a href="http://www.celestegame.com/">Celeste</a>. Celeste has a large speed running and modding scene, it also features complex mechanics and entirely deterministic gameplay. These features make it an excellent candidate for NEAT. I installed <a href="https://everestapi.github.io/">Everest</a>, a Celeste mod loader and modding API. By opening the game and enabling debug mode, I discovered that the necessary components for NEAT were made readily available by Everest: the player's position, the level tiles, and special entities like spikes and springs. The stages were even labeled in numerically increasing order from the start to the end of the level. This should make it possible to either develop a mod that performs NEAT in a self contained format, or develop a mod that supplies entity information for use in a 3rd party program running NEAT. I'll have to experiment a lot with Fitness metrics. One option is to track the distance the player is from the end of the level at any given time. Another possibility involves tracking the distance the player is from the next stage toward the end of the level. This would require more work initially, but might yield faster results. I'm excited to start applying NEAT to Celeste in the near future.</p>
<p><!-- /wp:paragraph --></p>

  </div><a class="u-url" href="/2019/02/10/neural-networks-playing-platformers/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Your awesome title</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Your awesome title</li><li><a class="u-email" href="mailto:your-email@example.com">your-email@example.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
