<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Speeeed (and Serialization) | Project Zoran</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Speeeed (and Serialization)" />
<meta name="author" content="mawz" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This week my objectives were to speed up the machine learning process, and to develop a method for saving and loading CelesteBot brain data between sessions. I was able to accomplish both goals. Speeding up the game ended up being trivially easy. All that was necessary was to call the call the original Engine Update function multiple times from within the hooked Engine Update function. I decided to call Update 10 times a function call, resulting in a 10x speedup in the game. I also added a keybinding to control the speedup - F engages fast mode and Shift+F disengages it. The second task was harder to complete. The original developer sc2ad already had some logic in place to serialize and deserialize the Population (the data structure containing all NEAT specific data). It used the C# BinaryFormatter, and saved a copy of the population to a file every 3 generations by default. It also allowed the user to load a previous generation with the &#39; key. Unfortunately, this logic was incomplete and produced files that were identical every time. These files could not be loaded and were effectively useless. My first step was to fix the original logic by adding the [Serializable] tag to the Population class and all it&#39;s necessary sub classes. This change alone resulted in checkpoint files that differed from each other. It was not enough to be able to load generations between sessions, though. The BinaryFormatter produces serialized classes that are meant to be used in the same program, it doesn&#39;t save enough data to reconstruct a class across different sessions or programs. To do something like that, we need to serialize to an XML or JSON. The next option I tried was the XmlSerializer. This fully serializes a class to an XML file, and can deserialize from that file in another program. Unfortunately, it is rather limited by its implementation method, as I discovered while trying to use it. It uses reflection to deserialize data, meaning it needs a parameterless constructor which it calls, followed by assigning public variables to their values. This by itself is OK, I was able to get around this requirement by creating empty parameterless constructors wherever required. I was also able to ignore variables for which creating a parameterless constructor was impossible, like the Celeste Player. The main deal breaker was it&#39;s inability to serialize dictionaries. That, and it&#39;s inability to handle circular references. I moved on to DataContractJsonSerializer. This class functions a little differently from XmlSerializer. Instead of the [Serializable] tag, it uses [DataContract] for classes. Any variables you want serialized also have to be tagged with the [DataMember] tag. For nested classes, it&#39;s usually necessary to specify known classes to be serialized and deserialized. My KnownTypes include CelestePlayer, ConnectionHistory, GeneConnection, Genome, Node, Population, and Species. After that, it&#39;s a simple matter of using the serializer to save and load data to and from a file. I initially got errors because JsonSerializer is also unable to handle circular references. To fix this, I simply switched to the DataContractSerializer, and added (IsReference = true) to my [DataContract] tags. Suddenly, saving and loading populations worked perfectly! These files also happen to be rather large. Checkpoint 0 was 13 MB, but by Checkpoint 300, the file size had grown to 34 MB. My folder containing checkpoints every 3 generations up to generation 675 is 6.83 GB. I will likely decrease the frequency of check pointing for future tests. I ran CelesteBot for an extended duration again. Again, I ran into the issue mentioned last week, this time 11 minutes in. As a reminder, the mod didn&#39;t reset the player to the beginning of the level correctly, so one species had an artificially high fitness. This currently appears to be the biggest barrier to the bot performing well. I will need to investigate methods of resetting the player without relying on a death timer, as the death timer has proven to be unreliable. This is my main goal for next week, along with fixing any minor bugs I come across. After that, I&#39;d like to run the bot for an extended duration and see if it can beat level 1A. This is getting exciting, I&#39;m so close to achieving something significant!" />
<meta property="og:description" content="This week my objectives were to speed up the machine learning process, and to develop a method for saving and loading CelesteBot brain data between sessions. I was able to accomplish both goals. Speeding up the game ended up being trivially easy. All that was necessary was to call the call the original Engine Update function multiple times from within the hooked Engine Update function. I decided to call Update 10 times a function call, resulting in a 10x speedup in the game. I also added a keybinding to control the speedup - F engages fast mode and Shift+F disengages it. The second task was harder to complete. The original developer sc2ad already had some logic in place to serialize and deserialize the Population (the data structure containing all NEAT specific data). It used the C# BinaryFormatter, and saved a copy of the population to a file every 3 generations by default. It also allowed the user to load a previous generation with the &#39; key. Unfortunately, this logic was incomplete and produced files that were identical every time. These files could not be loaded and were effectively useless. My first step was to fix the original logic by adding the [Serializable] tag to the Population class and all it&#39;s necessary sub classes. This change alone resulted in checkpoint files that differed from each other. It was not enough to be able to load generations between sessions, though. The BinaryFormatter produces serialized classes that are meant to be used in the same program, it doesn&#39;t save enough data to reconstruct a class across different sessions or programs. To do something like that, we need to serialize to an XML or JSON. The next option I tried was the XmlSerializer. This fully serializes a class to an XML file, and can deserialize from that file in another program. Unfortunately, it is rather limited by its implementation method, as I discovered while trying to use it. It uses reflection to deserialize data, meaning it needs a parameterless constructor which it calls, followed by assigning public variables to their values. This by itself is OK, I was able to get around this requirement by creating empty parameterless constructors wherever required. I was also able to ignore variables for which creating a parameterless constructor was impossible, like the Celeste Player. The main deal breaker was it&#39;s inability to serialize dictionaries. That, and it&#39;s inability to handle circular references. I moved on to DataContractJsonSerializer. This class functions a little differently from XmlSerializer. Instead of the [Serializable] tag, it uses [DataContract] for classes. Any variables you want serialized also have to be tagged with the [DataMember] tag. For nested classes, it&#39;s usually necessary to specify known classes to be serialized and deserialized. My KnownTypes include CelestePlayer, ConnectionHistory, GeneConnection, Genome, Node, Population, and Species. After that, it&#39;s a simple matter of using the serializer to save and load data to and from a file. I initially got errors because JsonSerializer is also unable to handle circular references. To fix this, I simply switched to the DataContractSerializer, and added (IsReference = true) to my [DataContract] tags. Suddenly, saving and loading populations worked perfectly! These files also happen to be rather large. Checkpoint 0 was 13 MB, but by Checkpoint 300, the file size had grown to 34 MB. My folder containing checkpoints every 3 generations up to generation 675 is 6.83 GB. I will likely decrease the frequency of check pointing for future tests. I ran CelesteBot for an extended duration again. Again, I ran into the issue mentioned last week, this time 11 minutes in. As a reminder, the mod didn&#39;t reset the player to the beginning of the level correctly, so one species had an artificially high fitness. This currently appears to be the biggest barrier to the bot performing well. I will need to investigate methods of resetting the player without relying on a death timer, as the death timer has proven to be unreliable. This is my main goal for next week, along with fixing any minor bugs I come across. After that, I&#39;d like to run the bot for an extended duration and see if it can beat level 1A. This is getting exciting, I&#39;m so close to achieving something significant!" />
<link rel="canonical" href="https://projectzoran.com/2019/03/22/speeeed-and-serialization/" />
<meta property="og:url" content="https://projectzoran.com/2019/03/22/speeeed-and-serialization/" />
<meta property="og:site_name" content="Project Zoran" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-03-22T15:16:55-07:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Speeeed (and Serialization)" />
<script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"https://projectzoran.com/2019/03/22/speeeed-and-serialization/"},"@type":"BlogPosting","url":"https://projectzoran.com/2019/03/22/speeeed-and-serialization/","author":{"@type":"Person","name":"mawz"},"headline":"Speeeed (and Serialization)","dateModified":"2019-03-22T15:16:55-07:00","datePublished":"2019-03-22T15:16:55-07:00","description":"This week my objectives were to speed up the machine learning process, and to develop a method for saving and loading CelesteBot brain data between sessions. I was able to accomplish both goals. Speeding up the game ended up being trivially easy. All that was necessary was to call the call the original Engine Update function multiple times from within the hooked Engine Update function. I decided to call Update 10 times a function call, resulting in a 10x speedup in the game. I also added a keybinding to control the speedup - F engages fast mode and Shift+F disengages it. The second task was harder to complete. The original developer sc2ad already had some logic in place to serialize and deserialize the Population (the data structure containing all NEAT specific data). It used the C# BinaryFormatter, and saved a copy of the population to a file every 3 generations by default. It also allowed the user to load a previous generation with the &#39; key. Unfortunately, this logic was incomplete and produced files that were identical every time. These files could not be loaded and were effectively useless. My first step was to fix the original logic by adding the [Serializable] tag to the Population class and all it&#39;s necessary sub classes. This change alone resulted in checkpoint files that differed from each other. It was not enough to be able to load generations between sessions, though. The BinaryFormatter produces serialized classes that are meant to be used in the same program, it doesn&#39;t save enough data to reconstruct a class across different sessions or programs. To do something like that, we need to serialize to an XML or JSON. The next option I tried was the XmlSerializer. This fully serializes a class to an XML file, and can deserialize from that file in another program. Unfortunately, it is rather limited by its implementation method, as I discovered while trying to use it. It uses reflection to deserialize data, meaning it needs a parameterless constructor which it calls, followed by assigning public variables to their values. This by itself is OK, I was able to get around this requirement by creating empty parameterless constructors wherever required. I was also able to ignore variables for which creating a parameterless constructor was impossible, like the Celeste Player. The main deal breaker was it&#39;s inability to serialize dictionaries. That, and it&#39;s inability to handle circular references. I moved on to DataContractJsonSerializer. This class functions a little differently from XmlSerializer. Instead of the [Serializable] tag, it uses [DataContract] for classes. Any variables you want serialized also have to be tagged with the [DataMember] tag. For nested classes, it&#39;s usually necessary to specify known classes to be serialized and deserialized. My KnownTypes include CelestePlayer, ConnectionHistory, GeneConnection, Genome, Node, Population, and Species. After that, it&#39;s a simple matter of using the serializer to save and load data to and from a file. I initially got errors because JsonSerializer is also unable to handle circular references. To fix this, I simply switched to the DataContractSerializer, and added (IsReference = true) to my [DataContract] tags. Suddenly, saving and loading populations worked perfectly! These files also happen to be rather large. Checkpoint 0 was 13 MB, but by Checkpoint 300, the file size had grown to 34 MB. My folder containing checkpoints every 3 generations up to generation 675 is 6.83 GB. I will likely decrease the frequency of check pointing for future tests. I ran CelesteBot for an extended duration again. Again, I ran into the issue mentioned last week, this time 11 minutes in. As a reminder, the mod didn&#39;t reset the player to the beginning of the level correctly, so one species had an artificially high fitness. This currently appears to be the biggest barrier to the bot performing well. I will need to investigate methods of resetting the player without relying on a death timer, as the death timer has proven to be unreliable. This is my main goal for next week, along with fixing any minor bugs I come across. After that, I&#39;d like to run the bot for an extended duration and see if it can beat level 1A. This is getting exciting, I&#39;m so close to achieving something significant!","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://projectzoran.com/feed.xml" title="Project Zoran" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Project Zoran</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">Statement of Purpose</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Speeeed (and Serialization)</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-03-22T15:16:55-07:00" itemprop="datePublished">Mar 22, 2019
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">mawz</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><!-- wp:paragraph --></p>
<p>This week my objectives were to speed up the machine learning process, and to develop a method for saving and loading CelesteBot brain data between sessions. I was able to accomplish both goals.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Speeding up the game ended up being trivially easy. All that was necessary was to call the call the original Engine Update function multiple times from within the hooked Engine Update function. I decided to call Update 10 times a function call, resulting in a 10x speedup in the game. I also added a keybinding to control the speedup - F engages fast mode and Shift+F disengages it.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>The second task was harder to complete. The original developer sc2ad already had some logic in place to serialize and deserialize the Population (the data structure containing all NEAT specific data). It used the C# BinaryFormatter, and saved a copy of the population to a file every 3 generations by default. It also allowed the user to load a previous generation with the ' key. Unfortunately, this logic was incomplete and produced files that were identical every time. These files could not be loaded and were effectively useless.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>My first step was to fix the original logic by adding the [Serializable] tag to the Population class and all it's necessary sub classes. This change alone resulted in checkpoint files that differed from each other. It was not enough to be able to load generations between sessions, though. The BinaryFormatter produces serialized classes that are meant to be used in the same program, it doesn't save enough data to reconstruct a class across different sessions or programs. To do something like that, we need to serialize to an XML or JSON.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>The next option I tried was the XmlSerializer. This fully serializes a class to an XML file, and can deserialize from that file in another program. Unfortunately, it is rather limited by its implementation method, as I discovered while trying to use it. It uses reflection to deserialize data, meaning it needs a parameterless constructor which it calls, followed by assigning public variables to their values. This by itself is OK, I was able to get around this requirement by creating empty parameterless constructors wherever required. I was also able to ignore variables for which creating a parameterless constructor was impossible, like the Celeste Player. The main deal breaker was it's inability to serialize dictionaries. That, and it's inability to handle circular references.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>I moved on to DataContractJsonSerializer. This class functions a little differently from XmlSerializer. Instead of the [Serializable] tag, it uses [DataContract] for classes. Any variables you want serialized also have to be tagged with the [DataMember] tag. For nested classes, it's usually necessary to specify known classes to be serialized and deserialized. My KnownTypes include CelestePlayer, ConnectionHistory, GeneConnection, Genome, Node, Population, and Species. After that, it's a simple matter of using the serializer to save and load data to and from a file. I initially got errors because JsonSerializer is also unable to handle circular references. To fix this, I simply switched to the DataContractSerializer, and added (IsReference = true) to my [DataContract] tags. Suddenly, saving and loading populations worked perfectly!</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>These files also happen to be rather large. Checkpoint 0 was 13 MB, but by Checkpoint 300, the file size had grown to 34 MB. My folder containing checkpoints every 3 generations up to generation 675 is 6.83 GB. I will likely decrease the frequency of check pointing for future tests.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:core-embed/youtube {"url":"https:\/\/youtu.be\/ygrkibDWOro","type":"video","providerNameSlug":"youtube","className":"wp-embed-aspect-4-3 wp-has-aspect-ratio"} --></p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/ygrkibDWOro" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p><!-- /wp:core-embed/youtube --></p>
<p><!-- wp:paragraph --></p>
<p>I ran CelesteBot for an extended duration again. Again, I ran into the issue mentioned last week, this time 11 minutes in. As a reminder, the mod didn't reset the player to the beginning of the level correctly, so one species had an artificially high fitness. This currently appears to be the biggest barrier to the bot performing well. I will need to investigate methods of resetting the player without relying on a death timer, as the death timer has proven to be unreliable. This is my main goal for next week, along with fixing any minor bugs I come across. After that, I'd like to run the bot for an extended duration and see if it can beat level 1A. This is getting exciting, I'm so close to achieving something significant!</p>
<p><!-- /wp:paragraph --></p>

  </div><a class="u-url" href="/2019/03/22/speeeed-and-serialization/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Project Zoran</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Project Zoran</li><li><a class="u-email" href="mailto:mwwaltz@umich.edu">mwwaltz@umich.edu</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/bercribe"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">bercribe</span></a></li><li><a href="https://www.twitter.com/bercribe"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">bercribe</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Development blog for a speed running research project. See my other work at https://matoskawaltz.com</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
